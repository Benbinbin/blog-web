<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <link rel="icon" href="/blog-web/images/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/katex.min.css"><title>对象 | Blog</title><meta name="description" content="A blog and knowledge management system about web.">
    <link rel="modulepreload" href="/blog-web/assets/app.43fe0c63.js"><link rel="modulepreload" href="/blog-web/assets/对象.html.a9cde160.js"><link rel="modulepreload" href="/blog-web/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/blog-web/assets/对象.html.54fc43d0.js">
    <link rel="stylesheet" href="/blog-web/assets/style.b42fd117.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="min-h-screen flex flex-col"><nav class="px-4 sm:px-8 py-2 flex justify-between items-center sticky top-0 z-30 bg-white"><div class="left flex items-center space-x-0.5"><!--[--><button class="text-gray-400 hover:bg-gray-100 catelog-btn p-2 select-none text-sm font-bold hover:text-gray-900 rounded-md lg:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path></svg></button><!--]--><a class="avatar p-2 hover:bg-gray-100 rounded-md" href="/blog-web/#"><img src="/blog-web/images/avatar.png" alt="avatar" class="w-10 h-10 rounded-full"></a></div><div class="right hidden sm:flex items-center space-x-0.5"><!--[--><button class="text-gray-400 p-2 select-none text-sm font-bold hover:text-gray-900 hover:bg-gray-100 rounded-md">All</button><button class="text-gray-400 p-2 select-none text-sm font-bold hover:text-gray-900 hover:bg-gray-100 rounded-md">Network</button><button class="text-gray-400 p-2 select-none text-sm font-bold hover:text-gray-900 hover:bg-gray-100 rounded-md">Frontend</button><button class="text-gray-400 p-2 select-none text-sm font-bold hover:text-gray-900 hover:bg-gray-100 rounded-md">Backend</button><button class="text-gray-400 p-2 select-none text-sm font-bold hover:text-gray-900 hover:bg-gray-100 rounded-md">Project</button><!--]--><!--[--><button class="text-gray-900 bg-gray-100 hover:bg-gray-200 p-2 select-none text-sm font-bold hover:text-gray-900 rounded-md hidden lg:block"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path></svg></button><!--]--></div><div class="more-container sm:hidden relative"><button style="" class="p-2 select-none hover:bg-gray-100 rounded-md text-gray-500"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"></path></svg></button><button style="display:none;" class="p-2 select-none hover:bg-gray-100 rounded-md text-red-400 hover:text-red-500"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"></path><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"></path></svg></button><div style="display:none;" class="more-modal p-2 absolute top-10 right-0 z-10 flex flex-col space-y-2 bg-gray-100 rounded-md opacity-90"><!--[--><button class="text-gray-400 px-4 py-2 select-none text-sm text-center font-bold hover:text-gray-900 hover:bg-gray-200 rounded-md">All</button><button class="text-gray-400 px-4 py-2 select-none text-sm text-center font-bold hover:text-gray-900 hover:bg-gray-200 rounded-md">Network</button><button class="text-gray-400 px-4 py-2 select-none text-sm text-center font-bold hover:text-gray-900 hover:bg-gray-200 rounded-md">Frontend</button><button class="text-gray-400 px-4 py-2 select-none text-sm text-center font-bold hover:text-gray-900 hover:bg-gray-200 rounded-md">Backend</button><button class="text-gray-400 px-4 py-2 select-none text-sm text-center font-bold hover:text-gray-900 hover:bg-gray-200 rounded-md">Project</button><!--]--></div></div></nav><div class="relative flex-grow"><div class="theme-container no-navbar no-sidebar"><!--[--><!----><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h1><p>对象是 JavaScript 支持的一种数据类型，与七种原生类型不同，对象可以用来存储键值对和更复杂的实体。</p><p>JavaScript 有内置对象，如 array 数组，此外 JavaScript 允许用户创建自定义对象，用于存储复杂的类型的数据值，其基本构成是 <strong>属性</strong> 和 <strong>方法</strong>，用以映射模拟现实中的对象。</p><p>当我们在代码中用对象表示实体时，就是所谓的 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener noreferrer">面向对象编程</a>，简称为 &quot;OOP&quot;。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 创建一个空对象</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 「构造函数」的语法</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 「字面量」的语法</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>整个对象以花括号 <code>{}</code> 包括，并将其赋值给一个变量（最后以分号 <code>;</code> 结束）</li><li>使用<strong>键值对 <code>key: value</code></strong> 形式创建属性或方法，该形式称为<strong>对象字面值记法</strong>。「键」key 是一个字符串（表示属性或方法名称），「值」 value 可以是任何值，它们之间用冒号 <code>:</code> 隔开</li><li>一个属性就是一个键值对，不同的方法或属性之间以逗号 <code>,</code> 分隔</li></ul><p>💡 为了代码更易阅读理解，每个键值对单独放置一行</p><h2 id="引用" tabindex="-1"><a class="header-anchor" href="#引用" aria-hidden="true">#</a> 引用</h2><p>对象与其他原始数据类型的一个根本区别是对象类型是通过<strong>引用</strong>来读取的。</p><p>💡 对于使用关键字 <code>const</code> 创建的常量变量引用的对象，即使对象进行修改也不会导致错误。因为 <code>const</code> 修饰的只是变量本身存储的值，即对同一个对象的引用。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 修改的是对象内部的内容，并没有改变 user 存储的对象的引用</span>
user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 25</span>

<span class="token comment">// 错误，不能再给 user 赋值</span>
user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Pete&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="复制" tabindex="-1"><a class="header-anchor" href="#复制" aria-hidden="true">#</a> 复制</h3><p>原始类型数据是整体被赋值或复制的，变量复制后会「独占」一份数据，因此修改变量存储的数据是相互不影响的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> phrase <span class="token operator">=</span> message<span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/blog-web/assets/20200324151131681_185.a985dfce.png" alt="primitive-data"></p><p>而当变量存储对象类型的数据时，并非存储对象本身而是相应的「内存中的地址」，所以复制这样的变量或者将其作为函数参数进行传递时，复制或传递的是「内存地址」而不是对象本身，即引用被复制了一份对象并没有被复制。可以将对象想象成是一个抽屉，变量就是一把钥匙，拷贝对象时相当于复制了钥匙，但是并没有复制抽屉本身。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> user<span class="token punctuation">;</span> <span class="token comment">// 复制引用</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="/blog-web/assets/20200324152109870_9316.65ca924a.png" alt="object-variable"></p><p>两个变量，但是都指向同一个对象，因此改变其中一个变量所指向的对象的属性值，另一个变量也随之改变。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>admin<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;Pete&#39;</span><span class="token punctuation">;</span> <span class="token comment">//  被通过名为 &quot;admin&quot; 的引用修改了</span>

<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Pete&#39;，通过名为 &quot;user&quot; 的引用查看修改</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>💡 如果需要创建一份独立的对象拷贝而非复制其指向引用，需要创建一个新的对象，然后遍历现有对象的属性，手动将对象的所有属性都复制一份。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">30</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 新的空对象</span>

<span class="token comment">// 复制所有的属性值</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现在的复制是独立的了</span>
clone<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Pete&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 改变它的值</span>

<span class="token function">alert</span><span class="token punctuation">(</span> user<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John，原对象属性值不变</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>💡 使用内置函数 <code>Object.assign(dest, [ src1, src2...])</code> 将（多个）对象 <code>src1</code>、<code>src2</code>……属性都拷贝（合并）到目标对象 <code>dest</code> 中。如果用于接收的对象（user）已经有了同样属性名的属性，已有的则会被覆盖。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> permissions1 <span class="token operator">=</span> <span class="token punctuation">{</span> canView<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> permissions2 <span class="token operator">=</span> <span class="token punctuation">{</span> canEdit<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 把 permissions1 和 permissions2 的所有属性都拷贝给 user</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> permissions1<span class="token punctuation">,</span> permissions2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在 user = { name: &quot;John&quot;, canView: true, canEdit: true }</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>⚠️ 当「源」对象的属性值也是对象，则对属性分别进行复制时，拷贝的就是其他对象的引用，即共享了一个对象，需要进行深拷贝 deep cloning 即对其中「内嵌」的对象的属性也进行一遍复制，可以使用一个标准的深拷贝算法 <strong><a href="https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data" target="_blank" rel="noopener noreferrer">结构化克隆算法（Structured cloning algorithm）</a></strong> 解决更复杂的情况。一个 JavaScript 库 <a href="https://lodash.com/" target="_blank" rel="noopener noreferrer">lodash</a> 中的一个方法 <a href="https://lodash.com/docs#cloneDeep" target="_blank" rel="noopener noreferrer">_.cloneDeep(obj)</a> 实现。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  sizes<span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token comment">// 该属性是对另一个对象的引用</span>
    height<span class="token operator">:</span> <span class="token number">182</span><span class="token punctuation">,</span>
    width<span class="token operator">:</span> <span class="token number">50</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> user<span class="token punctuation">.</span>sizes <span class="token operator">===</span> clone<span class="token punctuation">.</span>sizes <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，同一个对象</span>

<span class="token comment">// user 和 clone 共享 sizes 对象</span>
user<span class="token punctuation">.</span>sizes<span class="token punctuation">.</span>width<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token comment">// 在这里改变一个属性的值</span>
<span class="token function">alert</span><span class="token punctuation">(</span>clone<span class="token punctuation">.</span>sizes<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 51，在这里查看属性的值</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h3><p>等号 <code>==</code> 和严格相等 <code>===</code> 操作符对于对象来说没差别。</p><p>⚠️ 两个对象只有在它们其实是<strong>同一个对象</strong>时才会相等。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 复制引用</span>

<span class="token function">alert</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，两个变量指向同一个对象</span>
<span class="token function">alert</span><span class="token punctuation">(</span> a <span class="token operator">===</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 两个独立的对象</span>

<span class="token function">alert</span><span class="token punctuation">(</span> a <span class="token operator">==</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>💡 对于像 <code>obj1 &gt; obj2</code> 这样两个对象的比较，或对象与原始值的比较 <code>obj == 5</code> 对象会被转换成原始值，这种比较真的极少用到。</p><h2 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h2><p><strong>属性</strong> 是关于对象的信息，以键值对的形式组成的一组数据，以描述对象的状态信息。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token comment">// 一个对象</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>   <span class="token comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span>
  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>   <span class="token comment">// 键 &quot;age&quot;，值 30</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>属性名可以是任意字符串（允许使用 <code>$</code> 和 <code>_</code>）或 <code>Symbol</code> 唯一标识符，其它类型将被自动地转化为字符串，甚至连保留字段（但不推荐这么做）可以被用作属性名（⚠️ 但不能作为变量名）</li><li>属性名称不需要引号包括（而 JSON 格式的键则必须用引号包括），但使用多字词语来作为属性名时必须给它们加上引号（虽然<strong>不</strong>推荐这么做）</li><li>属性名称为多词组成时，请勿使用空格或连字符分隔，推荐使用小驼峰式命名法</li></ul><p>⚠️ 只有一个特殊的 <code>__proto__</code> 因为历史原因要特别对待，不推荐作为属性名称 💡 列表中的最后一个属性也应以逗号 <code>,</code> 结尾，这叫做尾随 trailing 或悬挂 hanging 逗号，便于我们添加、删除和移动属性，因为所有的行都是相似的。</p><h3 id="计算型属性名" tabindex="-1"><a class="header-anchor" href="#计算型属性名" aria-hidden="true">#</a> 计算型属性名</h3><p>除了直接设置固定的属性名称，还可以使用变量或表达式作为属性名称，即属性名是通过计算得出的，该属性称为<strong>计算属性</strong>，使用中括号 <code>[]</code> 包括</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> fruit <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&quot;Which fruit to buy?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;apple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> bag <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>fruit <span class="token operator">+</span> <span class="token string">&#39;Computers&#39;</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">// 属性名是从 fruit 变量中得到的</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> bag<span class="token punctuation">[</span>fruit<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5，相当于 bag.appleComputers = 5</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="访问属性" tabindex="-1"><a class="header-anchor" href="#访问属性" aria-hidden="true">#</a> 访问属性</h3><p>类似查找字典，通过键名称可以查找关于对象的相应信息，可以使用括号记法或点记法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 两种等价的方法来使用 key 键 来返回它的 value 值</span>
user<span class="token punctuation">[</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 括号记法，需要使用引号包括属性名</span>
user<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">// 点记法</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>💡 推荐使用点符号访问属性值，这和调用对象方法语法一致，但对于有多词构成的属性名只能使用括号记法，因此推荐使用小驼峰命名法创建属性名</p><p>💡 方括号其实更强大，它允许任意字符串（在引号中）或表达式作为属性名，让属性名创建有较大的灵活性，可以是通过运算或允许用户输入自定义得到的。一种常见的做法是将字符串绑定到变量中，再通过变量名作为属性名（⚠️ 这种通过变量「中转」的方式不适用于点记法）。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token string">&quot;likes pigs&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span>
user<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="修改属性" tabindex="-1"><a class="header-anchor" href="#修改属性" aria-hidden="true">#</a> 修改属性</h3><p>创建对象（实例）后，可以通过重新赋值 <code>=</code> 来修改对象的已有属性的值，或添加新的属性。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 更改属性值</span>
user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Ben&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 添加属性</span>
user<span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token string">&quot;male&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用操作符 <code>delete</code> 移除对象已有的属性</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">delete</span> user<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>💡 函数也是一个对象，也是一种特殊的值，可以通过函数表达式的方式将匿名函数绑定到对象的属性上，该操作称为 <strong>封装函数</strong>。因此除了在定义对象时设置其方法，还可以通过封装函数的形式为对象（实例）添加方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// projects 是一个对象，将其属性 display 绑定到一个函数中</span>
projects<span class="token punctuation">.</span><span class="token function-variable function">display</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code_block</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用方法</span>
projects<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>💡 除了使用匿名函数创建函数表达式，还可以将<strong>预先声明的函数</strong>绑定到对象的属性 <code>obj.propertyName = functionName</code> ⚠️ 但在使用赋值号 <code>=</code> 绑定时<strong>不需要添加括号 <s><code>()</code></s></strong>。（如果使用了括号，就不是将函数代码体与对象的属性相绑定，而是将函数的运算结果与对象属性绑定，这涉及<a href="/blog-web/frontend/JavaScript/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/this%E5%85%B3%E9%94%AE%E5%AD%97.html" class="">函数/方法内的 <code>this</code></a> 不同，具体参考<a href="https://dev.to/krism4n5z/passing-this-in-callbacks-in-one-example-3g0i" target="_blank" rel="noopener noreferrer">该文</a>）</p><h3 id="属性存在性测试" tabindex="-1"><a class="header-anchor" href="#属性存在性测试" aria-hidden="true">#</a> 属性存在性测试</h3><p>访问对象不存在的属性时也不会报错，只是会返回 <code>undefined</code>，可以通过比较 对象属性的值（返回）是否与 <code>undefined</code> （严格）相等而判定对象是否有该属性。</p><p>⚠️ 检查属性是否存在时，使用严格比较 <code>=== undefined</code> 就够了，但如果属性存在而存储值为 <code>undefined</code>（这种情况很少发生，因为通常情况下是不会给对象赋值 <code>undefined</code> 而是使用 <code>null</code> 来表示未知的或者空的值），这时应该使用 JavaScript 内置的操作符 <code>in</code> 来实现相同的功能</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">&quot;age&quot;</span> <span class="token keyword">in</span> user <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，user.age 存在</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">&quot;blabla&quot;</span> <span class="token keyword">in</span> user <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，user.blabla 不存在。</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>💡 操作符 <code>in</code> 左边属性名是一个用引号包括的字符串，如果省略引号则意味着将测试包含实际名称的变量。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> age<span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token string">&quot;age&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> key <span class="token keyword">in</span> user <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，从 key 获取属性名并检查这个属性</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="属性标志" tabindex="-1"><a class="header-anchor" href="#属性标志" aria-hidden="true">#</a> 属性标志</h3><p>对象属性 properties 是用来存储对象状态的，一般一个属性对应一个值 <code>value</code>，实际上属性除了有值 <code>value</code> 以外，还有三个特殊的特性 attributes，也就是所谓的标志，可用于设置对象该属性的一些行为。</p><ul><li><strong><code>writable</code></strong> 如果为 <code>true</code> 则值可以被修改，否则它是只可读的。</li><li><strong><code>enumerable</code></strong> 如果为 <code>true</code> 则会被在循环中列出，否则不会被列出。</li><li><strong><code>configurable</code></strong> 如果为 <code>true</code> 则此特性可以被删除，这些属性也可以被修改，否则不可以。</li></ul><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener noreferrer">方法 <code>Object.getOwnPropertyDescriptor</code></a> 允许查询有关属性的 <strong>完整</strong> 信息，即返回值是一个所谓的「属性描述符」对象，它包含值 <code>value</code> 和所有的标志。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> propertyName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>参数说明：</p><ul><li><code>obj</code> 需要从中获取信息的对象。</li><li><code>propertyName</code> 属性的名称。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 返回属性描述符对象
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
}
*/</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>💡 如果希望一次获取素有对象属性描述符，可以使用<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noopener noreferrer">方法 <code>Object.getOwnPropertyDescriptors(obj)</code></a></p><p>方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener noreferrer"><code>Object.defineProperty</code></a> 可以定义/修改标志，如果需要设置的对象属性存在，就会更新其标志；如果属性不存在，就会使用给定的值和标志创建属性，此时对于没有提供设置的标志，则默认为 <code>false</code></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> propertyName<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>参数说明：</p><ul><li><code>obj</code>，<code>propertyName</code> 要应用描述符的对象及其属性。</li><li><code>descriptor</code> 要应用的属性描述符对象。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 设置属性标志，没有提供标志设置默认为 false</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: false,
  &quot;enumerable&quot;: false,
  &quot;configurable&quot;: false
}
 */</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>💡 用「常用的方式」创建一个对象属性时，其标志都为 <code>true</code>。</p><p>💡 如果希望一次设置多个属性的标志，可以使用<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener noreferrer">方法 <code>Object.defineProperties(obj, descriptors)</code></a></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  surname<span class="token operator">:</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通常结合方法 <code>Object.getOwnPropertyDescriptors(obj)</code> 和 <code>Object.defineProperties(obj, descriptors)</code> 克隆一个对象 <code>let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));</code> ，包括属性的标志和 symbol 类型的属性都会复制</p><p>而通常使用的循环读取对象属性，并以赋值的方式来复制就存在缺陷</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种方法并不能复制属性的标志，而且使用 <code>for..in</code> 循环会忽略 symbol 类型的属性。</p><p>⚠️ 当一个属性设置为不可配置 <code>configurable: false</code> 那么该对象的属性标志 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 就不能被修改和删除，不能修改访问者属性的 <code>get/set</code>（但是如果没有可以分配它们）。而且不可配置是一条单行道无法使用 <code>defineProperty</code> 改回去。不可配置性对 <code>defineProperty</code> 施加了一些限制：</p><p>💡 Non-configurable 并不意味着 non-writable，不可配置只是不可修改标志，如果 <code>writable: true</code> 那么属性值是可以修改的</p><p>类似地，可以使用不同的方法将对象「密封」，即在对象而非其属性层面上限制访问整个对象</p><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener noreferrer">Object.preventExtensions(obj)</a> 禁止向对象添加新属性。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener noreferrer">Object.seal(obj)</a> 禁止添加/删除/修改属性。为所有现有的属性设置 <code>configurable: false</code>。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener noreferrer">Object.freeze(obj)</a> 禁止添加/删除/更改属性。为所有现有的属性设置 <code>configurable: false, writable: false</code>。</li></ul><p>还有针对它们的测试：</p><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible" target="_blank" rel="noopener noreferrer">Object.isExtensible(obj)</a> 如果添加属性被禁止，则返回 <code>false</code>，否则返回 <code>true</code>。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed" target="_blank" rel="noopener noreferrer">Object.isSealed(obj)</a> 如果添加/删除属性被禁止，并且所有现有的属性都具有 <code>configurable: false</code>则返回 <code>true</code>。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen" target="_blank" rel="noopener noreferrer">Object.isFrozen(obj)</a> 如果添加/删除/更改属性被禁止，并且所有当前属性都是 <code>configurable: false, writable: false</code>，则返回 <code>true</code>。</li></ul><h3 id="访问器属性" tabindex="-1"><a class="header-anchor" href="#访问器属性" aria-hidden="true">#</a> 访问器属性</h3><p>一般使用的属性类型是 <strong>数据类型</strong>，即对象的属性具有 <code>value</code> 值；JavaScript 提供另一种类型的属性是<strong>访问器属性 accessor properties</strong>，它没有属性值 <code>value</code> 而是通过函数实现值的获取与设置的，但在「外部」访问该属性的值时和常规属性一致，也可以通过点记法或括号法进行读取。</p><p>访问器属性由 getter 和 sette 方法读取和设置值，在对象字面量中它们用 <code>get</code> 和 <code>set</code> 表示</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  surname<span class="token operator">:</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">,</span>

  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 设置访问器属性的值时 setter 起作用</span>
user<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&quot;Alice Cooper&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 使用常规的方式 user.fullName 读取访问器属性的值，getter 在幕后起作用</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// John Smith</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>访问器属性的描述符与数据属性的不同，它没有 <code>value</code> 和 <code>writable</code> 但是有 <code>get</code> 和 <code>set</code> 函数。</p><p>访问器属性的描述符：</p><ul><li><strong><code>get</code></strong> 一个没有参数的函数，在读取属性时工作，</li><li><strong><code>set</code></strong> 带有一个参数的函数，当属性被设置时调用，</li><li><strong><code>enumerable</code></strong> 与数据属性的相同，</li><li><strong><code>configurable</code></strong> 与数据属性的相同。</li></ul><p>💡 一个属性要么是访问器（具有 <code>get</code>/<code>set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是</p><p>访问器的一大用途是它们允许随时通过使用 <code>getter</code> 和 <code>setter</code> 替换数据属性，来控制和调整这些属性的行为，实例参考 <a href="https://zh.javascript.info/property-accessors#jian-rong-xing" target="_blank" rel="noopener noreferrer">兼容性</a>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birthday</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>

  <span class="token comment">// 年龄是根据当前日期和生日计算得出的</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;age&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> todayYear <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> todayYear <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1992</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> john<span class="token punctuation">.</span>birthday <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// birthday 是可访问的</span>
<span class="token function">alert</span><span class="token punctuation">(</span> john<span class="token punctuation">.</span>age <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// age 也是可访问的</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h2><p><strong>方法</strong>是与对象属性相关联的函数，以表示对象可执行的操作和功能。创建对象方法与函数创建类似，但需要通过<strong>键值对</strong>，即冒号 <code>:</code> 分隔的形式来创建和命名该方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">methodName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">parameters</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// code_block</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>💡 方法/函数也是对象的一种属性</p><p>除了可在声明对象时创建其方法，还可以在声明之外，通过函数表达式创建函数，并将函数绑定到对象的属性以为对象新增方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用函数表达式创建对象方法</span>
user<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

user<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello!</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>也可以使用预先声明的函数作为方法</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 首先，声明函数</span>
<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 然后将函数作为一个特殊的值，赋给对象的属性</span>
user<span class="token punctuation">.</span>sayHi <span class="token operator">=</span> sayHi<span class="token punctuation">;</span>

<span class="token comment">// 调用函数，即使用对象方法（需要使用小括号）</span>
user<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello!</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="调用方法" tabindex="-1"><a class="header-anchor" href="#调用方法" aria-hidden="true">#</a> 调用方法</h3><p>通过点记法调用对象的方法</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span>argument<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型" aria-hidden="true">#</a> 引用类型</h3><p>「复杂」的方法调用可能会失去方法中 <code>this</code> 所绑定的对象</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将赋值与方法调用拆分为两行</span>
<span class="token keyword">let</span> hi <span class="token operator">=</span> user<span class="token punctuation">.</span>hi<span class="token punctuation">;</span>
<span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// TypeError: Cannot read property &#39;name&#39; of undefined（错误，因为 this 未定义）</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>使用点记法调用对象方法 <code>obj.method()</code> 可以看作语句中有两个操作符</p><ul><li>点符号 &#39;.&#39; 取得这个 obj.method 属性</li><li>括号 () 调用它</li></ul><p><code>this</code> 从第一部分操作传递到第二部分操作是借助一种特殊的「中间」内部类型 <strong><a href="https://tc39.github.io/ecma262/#sec-reference-specification-type" target="_blank" rel="noopener noreferrer">引用类型</a></strong> 实现的。引用类型是一种在编程语言的内部的类型，它值是三部分的结合 <code>(base, name, strict)</code></p><ul><li><code>base</code> 是对象。</li><li><code>name</code> 是属性名。</li><li>在严格模式 <code>use strict</code> 下，<code>strict</code> 为真。</li></ul><p>因此使用点符号 <code>.</code> 和括号 <code>()</code> 连续操作时，第一部分操作 <code>user.hi</code> 返回的是引用类型（而不是单纯的函数代码），而是一个包含对象、属性名等信息的整体 <code>(user, &quot;hi&quot;, true)</code>，因此在第二部分操作时 <code>this</code> 可以正确指代到调用方法的对象上。</p><p>而如果将这两个操作分步进行，如先将对象的方法（函数可以作为一个特殊值）赋值给一个变量 <code>hi = user.hi</code> ，则引用类型作为一个整体丢弃，只获取 <code>user.hi</code>（单纯的函数代码）的值进行传递；因此再调用该函数 <code>hi()</code> 时 <code>this</code> 就无法正确指定对象。💡 可以通过其他办法，如 <code>func.bind()</code> 解决此问题。</p><p>💡 只有使用点符号 <code>obj.method()</code> 或方括号语法 <code>obj[method]()</code> 调用对象方法时，<code>this</code> 的值才被正确传递。</p><h2 id="对象字面量简写法" tabindex="-1"><a class="header-anchor" href="#对象字面量简写法" aria-hidden="true">#</a> 对象字面量简写法</h2><p>在实际开发中，通常用已存在的变量当做属性名，即属性名和存储着属性值的变量一样。</p><ul><li>若属性值是通过变量来调用其存储的数据，且属性名称和该变量名称一样，就可以删除重复部分，以简写法形式来创建属性</li><li>在创建对象并设置方法时（方法也是一种属性），一般使用匿名函数即 <code>function</code> 关键字，在简写法中可以删掉该关键字</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> type <span class="token operator">=</span> <span class="token string">&#39;quartz&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token string">&#39;rose&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> carat <span class="token operator">=</span> <span class="token number">21.29</span><span class="token punctuation">;</span>

<span class="token comment">// 简写法创建对象并设置对象属性和方法</span>
<span class="token keyword">const</span> gemstone <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">,</span> <span class="token comment">// 相当于 type: type,</span>
  color<span class="token punctuation">,</span>
  carat<span class="token punctuation">,</span>

  <span class="token comment">// 相当于 calculateWorth: function() {...}</span>
  <span class="token function">calculateWorth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code_block</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>💡 在同一对象声明中，可以把属性名简写方式和正常方式混用</p><p>💡 方法简写法与一般的方法声明法在对象继承方面有一些细微的差别，但在几乎所有的情况下较短的语法是首选的。</p><h2 id="全局对象" tabindex="-1"><a class="header-anchor" href="#全局对象" aria-hidden="true">#</a> 全局对象</h2><p>很多语言/环境默认情况下都内置全局对象，虽然它们的名字可能不一样，如对 Node.js 而言它的名字是 <code>global</code>，在浏览器中它的名字是 <code>window</code>，全局对象可提供在任何地方使用的变量和函数。</p><p>💡 最近 <code>globalThis</code> 被作为全局对象的<strong>标准名称</strong>加入到了 JavaScript 中，所有环境都应该支持该名称，但在有些浏览器中即 non-Chromium Edge，尚不支持 <code>globalThis</code>，但可以很容易地对其进行 polyfilled 填充。假设环境是浏览器可以使用 <code>window</code>，如果脚本可能会用来在其他环境中运行则最好使用 <code>globalThis</code>。</p><p>全局对象的所有属性都可以被直接访问（即可以省略对象 <code>window</code> 作为点记法的前缀）</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>💡 在浏览器中，使用 <code>var</code>（而不是 <code>let</code>/<code>const</code>）声明的全局函数和变量会成为全局对象 <code>window</code> 的属性。但是现代 JavaScript 代码应该避免使用关键字 <code>var</code>，而使用 <code>let</code> 声明的变量就不会出现这种情况</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> gVar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>gVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5（成为了全局对象的属性）</span>

<span class="token keyword">let</span> gLet <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>gLet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined（不会成为全局对象的属性）</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>⚠️ 如果一个值非常重要想使它在全局范围内可用，才将其作为属性写入全局对象。但一般全局变量应尽可能的少，与使用外部变量或全局变量相比，函数获取「输入」变量并产生特定「输出」的代码设计更加清晰，不易出错且更易于测试。</p><h2 id="对象原始值转换" tabindex="-1"><a class="header-anchor" href="#对象原始值转换" aria-hidden="true">#</a> 对象原始值转换</h2><p>对象也可以被转换为原生类型，如字符串类型、数字类型等，以进行相关操作。</p><h3 id="类型提示" tabindex="-1"><a class="header-anchor" href="#类型提示" aria-hidden="true">#</a> 类型提示</h3><p>对象一般会根据所需（这些依据也称为 <code>hints</code> 数据类型提示）转换为 <code>string</code> 或 <code>number</code> 这两种原生数据类型之一。有三种 <code>hints</code> 类型转换提示，分别是 <code>&quot;string&quot;</code>、<code>&quot;number&quot;</code> 和 <code>&quot;default&quot;</code>。</p><p>当对象参与相减相加 <code>+</code> 或 相减 <code>-</code> 运算或引用与数学函数（<code>Date</code> 对象可以相减以求得两个日期之间的差值）会发生数字类型转换，对应的 <code>hint</code> 为 <code>&quot;number&quot;</code>；当对象需要作为字符串使用，如作为 <code>alert(obj)</code> 参数时，会发生字符串类型转换，对应的 <code>hint</code> 为 <code>&quot;string&quot;</code>。</p><p>在少数情况下发生，当操作符<strong>不能明确所需的数据类型</strong>，此时的 <code>hint</code> 数据类型转换提示为 <code>&quot;default&quot;</code>。如二元加法操作符 <code>+</code> 可用于字符串连接，也可以用于数字相加，所以对象转换为这两种数据类型均可；如果对象被用于与字符串、数字或 <code>symbol</code> 进行 <code>==</code> 比较，这时到底应该进行哪种转换也不是很明确。</p><p>除了一种情况（<code>Date</code> 对象）之外，所有内建对象都以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 提示的转换。💡 如果我们将 <code>&quot;default&quot;</code> 和 <code>&quot;number&quot;</code> 视为相同，就像大多数内建函数一样，那么就只有两种转换了。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// obj == number 使用 default hint</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>💡 像 <code>&lt;</code> 和 <code>&gt;</code> 小于/大于比较运算符，也可以同时用于字符串和数字，但它们使用 <code>&quot;number&quot; hint</code>（而不是 <code>&quot;default&quot;</code>）这是历史原因。</p><p>💡 对象在布尔上下文中均为 <code>true</code> 因此不存在对象向布尔类型的转换一说，因此没有 <code>&quot;boolean&quot; hint</code>。</p><h3 id="类型转换方法" tabindex="-1"><a class="header-anchor" href="#类型转换方法" aria-hidden="true">#</a> 类型转换方法</h3><p>为了将对象转换为所需的原始数据类型，JavaScript <strong>自动尝试</strong>查找三个对象方法并调用其中之一：</p><ul><li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 方法（如果这个方法存在的话）将对象依据 <code>hint</code> 转换为对应原始类型。这是一个以 Symbol 为属性名的方法，该 Symbol 键为 <code>Symbol.toPrimitive</code>（系统 symbol）。</li><li>否则，如果 <code>hint</code> 是 <code>&quot;string&quot;</code> 就尝试 <code>obj.toString()</code> 和 <code>obj.valueOf()</code> 方法将对象转换为原始类型。</li><li>否则，如果 <code>hint</code> 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> 就尝试 <code>obj.valueOf()</code> 和 <code>obj.toString()</code> 方法将对象转换为原始类型。</li></ul><p>名为 <code>Symbol.toPrimitive</code> 的系统内建 <code>symbol</code> 是被用作对象原始值转换方法的属性名</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  money<span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>

  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">hint</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hint: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hint<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> hint <span class="token operator">==</span> <span class="token string">&quot;string&quot;</span> <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{name: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;}</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>money<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 转换演示：</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// {name: &quot;John&quot;}（此时 hint 为 string）</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1000（此时 hint 为 number）</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user <span class="token operator">+</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1500（此时 hint 为 default，但依据 number 情况进行转换）</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>💡 单个方法 <code>obj[Symbol.toPrimitive]</code> 即可处理所有的转换情况。</p><p>方法 <code>toString()</code> 和 <code>valueOf()</code> 来自「上古时代」，是「常规的」字符串命名的方法（那时候还没有 symbol 这个概念），它们是对于不同 <code>hint</code> 情况下实现不同转换的方法。</p><p>如果没有 <code>Symbol.toPrimitive</code> 那么 JavaScript 按照下面的顺序进行尝试</p><ul><li>对于 <code>hint</code> 为 <code>&quot;string&quot;</code> 时，先尝试 <code>toString()</code> 方法，不成功再尝试 <code>valueOf()</code>方法</li><li>其他情况下，先尝试 <code>valueOf()</code> 方法将对象进行原始值转换，不成功再尝试 <code>toString()</code> 方法</li></ul><p>实际上普通对象默认具有 <code>toString()</code> 和 <code>valueOf()</code> 方法，且都有返回值</p><ul><li><code>toString()</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code></li><li><code>valueOf()</code> 方法返回对象自身（因此这种默认转换可以忽略）</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [object Object]</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>通过「定制」转换方法，使用 <code>toString()</code> 和 <code>valueOf()</code> 的组合可以返回合理值</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  money<span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>

  <span class="token comment">// 对于 hint=&quot;string&quot;</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{name: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>money<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// {name: &quot;John&quot;}</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token operator">+</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1000</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user <span class="token operator">+</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1500</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>💡 所有对象的原始转换方法唯一强制性的是<strong>必须返回一个原始值，而不是对象</strong>。但它们不一定会返回 <code>&quot;hint&quot;</code> 所提示的原始数据类型，如没有限制 <code>toString()</code> 必须返回字符串，但如果返回的只要不是对象即可（<code>valueOf()</code> 方法返回对象自身因此这种默认转换可以忽略）。</p><p>💡 对象作为参数传递时，其数据类型可能出现进一步的转换</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// toString 在没有其他方法的情况下处理所有转换</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>obj <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>💡 由于存在「二次」数据类型转换，因此在实践中为了便于进行日志记录或调试，当对象转换后能够返回「可读性好」的字符串，这些对象可以只将 <code>obj.toString()</code> 作为全能转换的方法就够了。</p><h2 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h2><p>当我们需要创建许多<strong>类似的对象</strong>，除了可以使用常规的对象字面量方法 <code>{...}</code> 创建对象，还可以利用函数封装重复操作代码的特性，只要函数最后返回的是一个对象，即可通过调用这一函数创建类似的对象，这种函数称为<strong>构造函数</strong>，简称<strong>构造器</strong>。</p><p>💡 相似的对象称为 <strong>类 Class</strong> 的实例，⚠️ 但 JavaScript 原生不支持 Class 类，可以通过<a href="/blog-web/frontend/JavaScript/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%B1%BB.html" class="">多种方式模拟类</a>，<strong>构造函数法</strong>就是其中一种常用方法。JavaScript 为许多内置的对象提供了构造函数，如日期 <code>Date</code>、集合 <code>Set</code> 等。</p><p>构造函数在技术上是常规函数，不过有两个约定：</p><ul><li>它们的命名以<strong>大写字母开头</strong>，以表示该函数模拟 Class 类</li><li>它们只能<strong>由 <code>new</code> 操作符来调用</strong>，（表明调用的是构造函数）以实现自动创建新的空对象，并自动返回该对象</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">&quot;My name is: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用操作符 new 调用构造函数，返回一个对象</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;Ben&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 可以传递不同参数调用 new User(&quot;Ann&quot;)，new User(&quot;Alice&quot;) 等创建多个不同的对象，比每次都使用字面量创建要短得多。</span>

<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ben</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>isAdmin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
user<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// My name is: Ben</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>实际上当一个函数被 <code>new</code> 操作符调用时，它执行了以下一些额外步骤，以确保函数创建并返回一个对象：</p><ul><li>一个新的空对象被创建并分配给 <code>this</code>（隐式创建对象）</li><li>函数体执行。通常它会修改 <code>this</code>（即为对象添加新的属性和方法）</li><li>返回 <code>this</code> 的值（隐式返回对象）</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// this = {};（隐式创建）</span>

  <span class="token comment">// 添加属性到 this</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token comment">// return this;（隐式返回）</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>💡 构造器的主要目是可重用的对象创建代码，实际上任何函数都可以用作构造器，即任何函数都可以通过 new 来运行，它会执行上面的算法。首字母大写是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p><p>💡 如果调用时没有传递参数可以省略函数名后的括号，⚠️ 但省略括号不并不是一种好的编程风格</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>    <span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 没有参数</span>
    <span class="token comment">// 等同于</span>
    <span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="封装对象构造代码" tabindex="-1"><a class="header-anchor" href="#封装对象构造代码" aria-hidden="true">#</a> 封装对象构造代码</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 该构造器不能被再次调用，只是用于表示函数封装了创建一个特定对象的代码</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// code_block</span>
  <span class="token comment">// 用于创建该对象的其他代码</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="构造器测试模式" tabindex="-1"><a class="header-anchor" href="#构造器测试模式" aria-hidden="true">#</a> 构造器测试模式</h3><p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了。</p><ul><li>当函数是通过常规调用时，该属性值为为 <code>undefined</code></li><li>当函数是通过操作符 <code>new</code> 调用时，则属性值等于该函数（代码）</li></ul><p>该属性被用于库中以使语法更加灵活，这样人们在调用函数时，无论是否使用了 <code>new</code>，程序都能工作。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果你没有通过 new 运行我</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ……我会给你添加 new</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将调用重定向到新用户</span>
<span class="token function">alert</span><span class="token punctuation">(</span>john<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>⚠️ 但并不推荐示例的这种写法，因为代码封装后会让人感到疑惑，而应该显式使用 <code>new</code> 操作符来表示调用了构造函数以创建一个对象。</p><h3 id="构造器的返回值" tabindex="-1"><a class="header-anchor" href="#构造器的返回值" aria-hidden="true">#</a> 构造器的返回值</h3><p>通常，构造器没有 <code>return</code> 语句，它们的任务是将所有必要的东西写入 <code>this</code>（指向自动创建的新对象），并自动返回 <code>this</code>。</p><p>如果构造函数中有 <code>return</code> 语句，按照以下规则执行：</p><ul><li>如果 <code>return</code> 返回的是一个对象，则返回这个对象（覆盖 <code>this</code>）</li><li>如果 <code>return</code> 返回的是一个原始类型，则忽略</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">BigUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Godzilla&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 返回这个对象，覆盖 this</span>
<span class="token punctuation">}</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">BigUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Godzilla</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="原型继承" tabindex="-1"><a class="header-anchor" href="#原型继承" aria-hidden="true">#</a> 原型继承</h2><p>在编程中想基于原有的代码进行功能扩展，但不是复制代码而是基于已有代码（通过引用、继承等方法）构建一个新功能。在 JavaScript 中对象有一个特殊的<strong>隐藏属性 <code>[[Prototype]]</code><strong>可以实现该功能。它要么为 <code>null</code> 要么就是对另一个对象的引用，该对象被称为</strong>原型</strong>，当我们想要从 <code>object</code> 中读取一个缺失的属性/方法时，JavaScript 会自动从原型中获取该属性/方法，这种行为被称为 <strong>「原型继承」Prototypal inheritance</strong>。</p><p>⚠️ 隐藏属性 <code>[[Prototype]]</code> 的值可以是对象，也可以是 <code>null</code>，而其他的类型都会被忽略。</p><p><img src="data:image/png;base64,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" alt="prototype"></p><p>属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的，但有很多设置它的方式，如使用特殊关键字 <code>__proto__</code> 它是因历史原因留下来的 getter/setter 函数，在现代 JavaScript 编程中已替换为函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 原型</span>
<span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Animal walk&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

rabbit<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> animal<span class="token punctuation">;</span>   <span class="token comment">// 将 animal 设置为 rabbit 的原型，可以说 animal 是 rabbit 的原型，或者说 rabbit 的原型是从 animal 继承而来的</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true，属性不存在于 rabbit 中，所以 JavaScript 会顺着 [[Prototype]] 引用，在 animal 中查找（自下而上）</span>
rabbit<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Animal walk，方法也可以继承</span>
<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>jumps <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>💡 根据规范 <code>__proto__</code> 必须仅在浏览器环境下才能得到支持，但实际上包括服务端在内的所有环境都支持它。</p><p>原型可以「无限」链接下去，构成很长的原型链；但是引用不能形成闭环，如果我们试图在一个闭环中分配 <code>__proto__</code>，JavaScript 会抛出错误。此外只能有一个 <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承。</p><p>原型仅用于读取属性，对于写入/删除操作一般是直接在对象上进行（因此会在该对象上创建相应的属性，而不是覆盖原型的属性）。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Animal walk&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  __proto__<span class="token operator">:</span> animal   <span class="token comment">// 将 animal 设置为 rabbit 的原型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 修改 walk 方法</span>
rabbit<span class="token punctuation">.</span><span class="token function-variable function">walk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 直接在 rabbit 上创建方法 walk</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Rabbit! Bounce-bounce!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

rabbit<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Rabbit! Bounce-bounce!，调用 walk 方法时在原型链从下往上寻找，由于在对象 rabbit 中找到该方法并执行，而无需使用原型</span>
animal<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Animal walk，并不覆盖原型的方法</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>💡 访问器 accessor 属性是一个例外，因为分配 assignment 操作是由 setter 函数处理的。因此写入此类属性实际上与调用函数相同，而不是在该对象上新建相应的属性。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
  surname<span class="token operator">:</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">,</span>

  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>
  __proto__<span class="token operator">:</span> user<span class="token punctuation">,</span>
  isAdmin<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// John Smith</span>

<span class="token comment">// setter triggers!</span>
admin<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&quot;Alice Cooper&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 对属性 fullName 进行赋值设置，原型中有一个 setter 因此它会被调用</span>
<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Alice Cooper，对属性 fullName 进行访问，调用原型 user 中的 getter 方法，但是绑定的对象是 admin</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// John Smith，对属性 fullName 进行访问，调用原型 user 中的 getter 方法 绑定的对象是 user</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>如果使用原型的方法中存在 <code>this</code>，那么它始终是点符号 <code>.</code> 前面的对象（即指向调用的对象，而不一定是原型对象）。因此当继承的对象运行继承的方法时它们将仅修改自己的状态，而不会修改原型对象的状态。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// animal 有一些方法</span>
<span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isSleeping<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">I walk</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isSleeping <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">// 为调用的对象创建一个新的属性 isSleeping</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;White Rabbit&quot;</span><span class="token punctuation">,</span>
  __proto__<span class="token operator">:</span> animal
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 调用原型方法，但是 this 指向的是调用的对象，即 rabbit，因此为 rabbit 创建属性 isSleeping</span>
rabbit<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">.</span>isSleeping<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>isSleeping<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// undefined（原型中没有此属性）</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>💡 所以对于原型的方法，可以理解为代码是共享的，但对象状态不是。</p><p>⚠️ 对于循环结构 for-in 也会迭代从原型中继承的属性；而几乎所有对象键/值获取的方法，如 <code>Object.keys()</code>、<code>Object.values()</code> 等都忽略继承的属性</p><p><img src="/blog-web/assets/20200424130353723_4268.10d4cee1.png" alt="prototype-chain"></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  __proto__<span class="token operator">:</span> animal
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Object.keys 只返回自己的 key</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jumps</span>

<span class="token comment">// for..in 会遍历自己以及继承的键</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> rabbit<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jumps，然后是 eats</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>如果想在循环结构 for-in 中排除继承的属性可以使用内建<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener noreferrer">方法 <code>obj.hasOwnProperty(key)</code></a> 作为判断条件，如果该属性 <code>key</code> 是当前对象 <code>obj</code> 自己的（非继承的）则返回 <code>true</code>。此外由于循环结构 for-in 只会列出可枚举的属性，因此可以像全局对象原型 <code>Object.prototype</code> 那样将其属性的标志设置为 <code>enumerable:false</code>，避免在迭代时列出。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  __proto__<span class="token operator">:</span> animal
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> rabbit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> isOwn <span class="token operator">=</span> rabbit<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 通过条件语句过滤掉继承属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isOwn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Our: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Our: jumps</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Inherited: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inherited: eats</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="构造函数原型" tabindex="-1"><a class="header-anchor" href="#构造函数原型" aria-hidden="true">#</a> 构造函数原型</h3><p>对象可以使用构造函数 <code>new func()</code> 来创建，可以预先设置函数的属性 <code>func.prototype=obj</code> ，这样就可以在使用操作符 <code>new</code> 创建对象时，将该属性引用的对象 <code>obj</code> 设置为 <code>[[Prototype]]</code> 原型。</p><p>💡 这里的 <code>func.prototype</code> 指的是 <code>func</code> 函数（函数也是对象，可以为其设置属性）具有一个名为 <code>&quot;prototype&quot;</code> 的常规属性，听起来与「原型」这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。而起作用是在使用关键字 <code>new</code> 调用函数 <code>func</code> 创建新对象时，它才会成为新对象的原型 <code>[[Prototype]]</code>，而且 <code>func.prototype</code> 的值要么是一个对象，要么就是 <code>null</code>，其他值都不起作用。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> animal<span class="token punctuation">;</span>   <span class="token comment">// 为函数设置 prototype 属性，其字面意思是：当创建了一个 new Rabbit 时，把它的 [[Prototype]] 赋值为 animal</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token string">&quot;White Rabbit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// rabbit.__proto__ == animal</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><img src="/blog-web/assets/20200424162949573_5072.e5beb148.png" alt="F.prototype"></p><p>示意图 <code>&quot;prototype&quot;</code> 是一个水平箭头，表示一个常规属性；<code>[[Prototype]]</code> 是垂直的，表示 <code>rabbit</code> 继承自 <code>animal</code>。</p><p>⚠️ 如果使用构造函数创建对象之后 <code>F.prototype</code> 属性有了变化 <code>F.prototype = &lt;another object&gt;</code>，那么之后通过 <code>new F</code> 创建的新对象也将随之拥有新的对象作为 <code>[[Prototype]]</code>，但已经存在的对象将保持旧有的值（因为已创建的对象是通过 <code>[[Prototype]]</code> 引用原型的，而改变 <code>F.prototype</code> 只是改变了引用指向另一个对象，因此只会影响后续通过构造函数创建的新对象的原型引用）。而如果修改方式通过构造函数的属性修改其引用对象的值，那么通过构造函数创建的对象，其原型也会变化，因为它们引用的都是同一个对象。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用构造函数创建对象</span>

<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// 更改引用</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true，并不影响之前创建的对象</span>

<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>eats <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment">// 直接修改原型对象的内容</span>

<span class="token function">alert</span><span class="token punctuation">(</span> rabbit<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// false</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>实际上每个函数都有 <code>prototype</code> 属性（即使我们没有提供它），而且默认的 <code>prototype</code> 是一个只有属性 <code>constructor</code> 的对象，而属性 <code>constructor</code> 指向函数自身。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">/* default prototype
Rabbit.prototype = { constructor: Rabbit };
*/</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="/blog-web/assets/20200424164603194_13880.91981f9a.png" alt="constructor"></p><p>因此通过构造函数创建的对象（即使构造函数没有显性设置 <code>func.prototype</code> 属性）默认也是有原型 <code>[[Prototype]]</code>，而且可以通过原型的属性 <code>constructor</code> 可以引用构造函数本身。当我们有一个对象但不知道它使用了哪个构造器（如来自第三方库），并且我们需要创建另一个类似的对象时，可以用 <code>constructor</code> 指向构造函数的特点<strong>基于现有的对象创建一个新对象</strong>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token string">&quot;White Rabbit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rabbit2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">rabbit<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token string">&quot;Black Rabbit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>⚠️ 以上方法是在默认情况下所有函数都有 <code>F.prototype = {constructor：F}</code> 可以通过访问它的 <code>&quot;constructor&quot;</code> 属性来获取一个对象的构造器。但如果我们将整个默认 <code>prototype</code> 替换掉，那么其中就不会有 <code>&quot;constructor&quot;</code> 了，这种「曲线救国」创建类似对象的方法就无效了，因此不推荐将构造函数的整个 <code>func.prototpye</code> 属性覆盖掉，而是选择添加/删除属性到默认的 <code>prototype</code> 指向的对象；或者在覆盖 <code>func.prototype</code> 属性后，手动出现创建 <code>constructor</code> 属性，指向回构造函数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 不要将 Rabbit.prototype 整个覆盖</span>
<span class="token comment">// 可以向其中添加内容</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>jumps <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">// 默认的 Rabbit.prototype.constructor 被保留了下来</span>

<span class="token comment">// 重新设置构造函数的 prototype 属性，覆盖了原有的 constructor，手动添加它指回构造函数</span>
<span class="token class-name">Rabbit</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  constructor<span class="token operator">:</span> Rabbit
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="原生原型" tabindex="-1"><a class="header-anchor" href="#原生原型" aria-hidden="true">#</a> 原生原型</h3><p>属性 <code>prototype</code> 在 JavaScript 自身的核心部分中被广泛地应用，所有的内置构造函数，如对象构造函数 <code>new Object()</code> ，都设置了属性 <code>Object.prototype</code>，它指向一个拥有多种方法的巨大对象，如方法 <code>toString</code>。</p><p><img src="/blog-web/assets/20200424230842114_19395.5e2cce1d.png" alt="Object.prototype"></p><p>当 <code>new Object()</code> 被调用（或一个字面量对象 <code>{...}</code> 被创建），这个对象的 <code>[[Prototype]]</code> 属性被设置为 <code>Object.prototype</code> 指向的对象，即使创建的是空对象，也可以通过原型继承了对象特有的方法。</p><p><img src="/blog-web/assets/20200424230937658_3504.b507335a.png" alt="obj Prototype"></p><p>JavaScript 内建对象的构造函数，如 <code>Array()</code>、<code>Date()</code>、<code>Function()</code> 等，也通过设置各自的属性 <code>.prototype</code> 为特定的对象「挂载」许多特有的方法。而且这些对象再设置原型为 <code>Object.prototype</code>（内建原型顶端），因此还具有对象通用的方法，这就是为什么有人说「一切都从对象继承而来」。</p><p><img src="/blog-web/assets/20200424231714571_15446.fb976c89.png" alt="obj Prototype chains"></p><p>💡 在 <code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code>（其上是 <code>null</code>）</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 原型链的顶端为 null。</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可在原型链上设置同名的方法以实现覆盖，即优先执行下层的原型方法，如 <code>Array.prototype</code> 有自己的 <code>toString</code> 方法来列举出来数组的所有元素并用逗号分隔每一个元素。</p><p><img src="/blog-web/assets/20200424232801060_6159.fb8834c2.png" alt="Array prototype"></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token function">alert</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1,2,3 &lt;-- Array.prototype.toString 的结果</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>💡 浏览器内的工具，像 Chrome 开发者控制台，会显示继承性（可能需要对内置对象使用 <code>console.dir</code>）</p><p><img src="/blog-web/assets/20200424233015033_16149.36d9b6ea.png" alt="console show prototype"></p><p>除了内置对象，<strong>基本数据类型</strong>也通过原型「挂载」多种方法/属性，但由于它们不是对象方式不一样略有不同。当试图访问它们的属性，那么<strong>临时包装器对象</strong>将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建，它们提供给我们操作字符串、数字和布尔值的方法然后消失。这些临时对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</p><p>可以为原生原型添加方法/属性，且适用于该数据类型的所有个体。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 向 String.prototype 中添加一个方法，对所有的字符串都是可用的</span>
<span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">show</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token string">&quot;BOOM!&quot;</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// BOOM!</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>⚠️ 原生原型是全局的所以很容易造成冲突，如有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖，所以通常来说修改原生原型被认为是一个很不好的想法。<strong>在现代编程中，只有一种情况下允许修改原生原型，那就是 polyfilling</strong>，即表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它并用以填充内建原型。</p><p>⚠️ 值 <code>null</code> 和 <code>undefined</code> 没有对象包装器，也没有相应的原型，所以它们没有方法和属性。</p><p>💡 此外还可以从原型<a href="https://zh.javascript.info/call-apply-decorators#method-borrowing" target="_blank" rel="noopener noreferrer"><strong>借用</strong>方法</a>，在不同类型的数据上也拥有类似的功能。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token operator">:</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token operator">:</span> <span class="token string">&quot;world!&quot;</span><span class="token punctuation">,</span>
  length<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;,&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello,world!</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>示例代码有效是因为数组的内建方法 <code>join</code> 的内部算法只关心正确的索引和 <code>length</code> 属性，它不会检查这个对象是否是真正的数组。</p><h3 id="原型方法" tabindex="-1"><a class="header-anchor" href="#原型方法" aria-hidden="true">#</a> 原型方法</h3><p>对象的隐藏属性 <code>[[Prototype]]</code> 有很多设置它的方式，如使用特殊关键字 <code>__proto__</code> 但它在 JavaScript 规范中规定认为是过时 deprecated 且不推荐使用的，在现代 JavaScript 编程中已替换为以下方法，应该使用这些方法来代替 <code>__proto__</code>。</p><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener noreferrer">方法 <code>Object.create(proto, [descriptors])</code></a> 利用给定的 <code>proto</code> 作为原型 <code>[[Prototype]]</code> 和可选的<strong>属性描述标志</strong>来创建一个<strong>空对象</strong>（或带有属性标志 <code>descriptors</code> 的对象）</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener noreferrer">方法 <code>Object.getPrototypeOf(obj)</code></a> 返回对象 <code>obj</code> 的原型 <code>[[Prototype]]</code></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener noreferrer">方法 <code>Object.setPrototypeOf(obj, proto)</code></a> 将对象 <code>obj</code> 的原型 <code>[[Prototype]]</code> 设置为 <code>proto</code></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  eats<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个以 animal 为原型的新对象，且添加属性描述器为新对象提供额外的属性</span>
<span class="token keyword">let</span> rabbit <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>animal<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  jumps<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">.</span>eats<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">.</span>jumps<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">)</span> <span class="token operator">===</span> animal<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true</span>

Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>rabbit<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将 rabbit 的原型修改为 {}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>💡 结合以上方法和对象属性描述符方法 <code>Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))</code> <strong>可以对 <code>obj</code> 进行真正准确地拷贝</strong>，包括所有的属性（可枚举和不可枚举的），囊括了数据属性和通过 setters/getters 设置的访问器属性，并带有正确的 <code>[[Prototype]]</code>。</p><p>⚠️ 虽然可以通过方法 <code>Object.setPrototypeOf(obj, newProto)</code> 或 <code>obj.__proto__=newProto</code> 可以更改对象的原型，但是这是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。如果速度对于程序很重要就请不要修改已存在的对象的 <code>[[Prototype]]</code></p><p>⚠️ 如果要将一个用户生成的键放入一个对象，那么内建的 <code>__proto__</code> getter/setter 是不安全的，因为用户可能会输入 <code>&quot;__proto__&quot;</code> 作为键，这会造成不可预料的后果（如果键对应的值刚好也是一个对象那么键值对就可以成功绑定，该对象的原型就会被用户在不知不觉中覆盖了）。为了避免这种特殊的情况发生，我们可以使用 <code>Object.create(null)</code> 创建一个被称为 &quot;very plain&quot; 或 &quot;pure dictionary&quot; 对象（这个对象没有原型，由于 <code>[[Prototype]]</code> 是 <code>null</code>），那么这种对象使用 <code>&quot;__proto__&quot;</code> 作为键是没有问题的（缺点是这样的对象没有任何内建的对象的方法）；或者对此类场景坚持使用 <code>Map</code> 对象就可以了。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAACkCAIAAADXI2+pAAAACXBIWXMAABJ0AAASdAHeZh94AAAJ5UlEQVR4nO3dT2gb2R0H8F+66S4pbbVLYKZeEh2yLIjAiHGcS6DgPQhjM0Hk5suCwMHW2RQZBD4aVKyDLr3IIemqzaFeegjaqDZeQ3B6yKFxJCTqFQVnwTYxM1uXattunHgd9TD6MyPL0sie0Uj6fT8nS/KMnpPvPP1m5um9C+VymQBY+onbDQBwDdIPfCH9wBfSD3wh/cAX0g98If3AF9IPfCH9wNdFtxvQl7S1udRKkYi8U+lJ6eTr+eXZ+R0iEsKhqCJ0u3VgFfr+sxDGFiOJBe+pr/snE+nQhK+LLYKzQPqBL46VT7VuUcYTYUoFV3P6077h6GJAICIq6E/KC5GQn4hqlcwpdQ70K459vzC2GImGPbT9LBZ8NnQvkkhHEulxuZi9n9GIiEgKpcdl4xb+yVZ1DvQrjumvKtLIvZkxUX8gTYQ92kZec7dJ0FWc0++7Jov1R8JVDxUPVPeaA13HOf3AHdIPfCH9zYlDPnq1Wz8L0HZLLrYGnIH0NycMfUL1k+D8cmyDBCrtG08LxMsC7bzI6w8KaxmtxR60zHrB+UZDhzhe77dECocm5lKxYJZIvxVwfSW4ujId36/dBBADd8MvY/Nx/XaBoIzLJAimPYzLwdXqHjwTV0nyd/mPgNYuYE4HYAuVD/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSH8Hjrb+5nYTwE5Iv1Xlo7f/+0P86O84AAYH0m/Vm6fp8n+/f/3VF243BGyD9FtSPnp7+PWXRHS8t43uf2Ag/ZboHb/+M7r/gYH0t1fr+HXHe9s4/R0MSH97b55+Vev4da/TX7jUFrAT0t9G+ejt4dfLDU+i+x8MSH8bJzt+Hbr/AYD0t9K049cd720fbT3vcnvAXkh/K2/++rhpx697nf59NxsDtkP6T1U+enu49qcWv4Duv98h/adq3fHr0P33NaS/ubYdv+54b/vom80utAecgPQ3Z6Xj1x3+5Y9ONwYcgvQ3YbHj1/34bRHdf59C+puw3vHr0P33Kaxe0cTxt99c/LRxWep32qt3pQMiOvkSER2ru++JV7vROLAPVq+w6ocvf/fm6eMLP/d8+Nvm97/qtMxSLNmwzpdxnfdCfYH4KiEciioCUW1d+BrPRH1RYdYKyfiDjPkp33B0MVBZL0ddj01nG1aPkmsL7TSHvt8hxv+YZlr+x9QTr2WWYtPxzdqxYYNCKrhKbWLh3OZnJ4UjiXD9oZZZim0YXhYD0XTA8LiQCq622yXq/t4mKDNTCmnJJ1j0zgHo+3uedMtLmdK+SpJorIu8U+lJqhYDgunDwVRZGT5kDM9XF9ur7cpwLnPWzdX12HSWGj+mCqng6qtw6C49iiVL5BuOLoor9f03vHVDAeN01Yf09xf/ZCJNeqQeBOPyQiQRJsovzz7Ma0pAoHoEE/WziHi1UJFCaSnUunQ5z+Zi4LaSfZB8UlAMgc5v5cg7pQgCzSSuLs/OZ2NBz8S9SEgk0kv54HL9AMgvz87vyAuRqJ+oUvUtkYMHACqfnld4tkO+a/KJBNR7ZfGyUDzQlxIuPMpqvuG7td7XPxkNe3LzyxYLp3NuLt0ZNqxhXG28cr0SbvGyQCQv1NMshcdlw5rHqfkdIRyqHVeCcmfCV9p83nAqayOkv7dpmaUHGZI/b3UCTWIgWuk+Cy8yJIz6jb8s3LzWuM72qc65OZHoH/FR7lntYNH2t0m4YjxwPUOmw1gc8tGrXY2ISFVfkWfkpunN5VGPtmfxvc8AlU8vKq1Mx1cqP3un0jNNbjB0uMN9lejs9YP1zYWxz70r81uFsCQRkZrfLHpGftPmapW2pxIJpB5opj+8Sjlbm61A+nuR7Wd7DT2uk5v7r8u0+iJPkp9IPdCa1WwG6n6RhFGRSK+LSiNdvbmBymegSDcU0jbyxkpZe/5SM8XXUGzYvHl9J7mH65pe9H8itur581u5WrUjih9bL7HsgfQPFunOsFDMxpLVyltdv58syQvGq4qCPOrRko/WqjkrJOOpvD2bG3byMqdq+9sk3zq9alPXY/M7pNyqdvZSaMGbmzftrZCMxzLOnfWi8ukvxnEQ1Yvupov9YiCaFlPB1dlM5U7nyZvKgjITpaVYrcJWxqOiRiTYsHmlDf4RX3ZlOkXknWq8MGqq7GsXNyv8k4mF5VnDzQQhHLp708I/yxkh/b2mckX/TK9W6BfmWxGUmcSpZ5Pn3JyIhLHFiJxZim1cPlHDtzulsfQH2gWVDzhCy22UGi6e9h6kH5yQf7JS9N62bWSeQ1D5OKSYjQWzhseNA1pypqEyDQN1+lZ9lI5n4t75b1OYNBvh3PSt6+Q2u8T4fqs6GN8PfQKVD/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/wZc9Ih+pcF+2mcKrQh+kq44mwvffCATpiT98vhdKRaNhj8be13RIR0bbq3NcWACxwY5Rbu9HhAN3RYfpN87M2rXOMXz4y1TaNU7cOyKhG6GOdpL+QjD/I1CbY0NbmUrE5Mh0AxWzs4XA0PVmdVGx1lqh6ABi/MaStzaWw4AO4zXrdr64/zpDhC87C2OK4XMzeN33p2DtVOxjEwN2whzJbmH4VepXl9GvPX2rkvWH6krJ0QyHTVFs+0/c4O5sGDKDbzn/Np82lG6Qfetb5r/m0mK5IPdDIMzIg6468J1y5+Kl04dIv3G4I2MZy+oWb14RktjJDXUXhRYaE8KnpLjzbId9wy4ns+sgHn9354LM7brcC7GS98hEDtxXKzS8ZJvFazRlnu26QX24/+TCAmzqpfKRwJHrFMImX+Xq//uFgmMjAO5WOYCQD9DB35nTQ1uZSm6O42wXucmeMp7pfdOV9AYy6ln51vT4zsHHeagDXdKvy0fLrKw+zuUqXjxWYoRdgLjfgC9/tAr6QfuAL6Qe+kH7gC+kHvpB+4AvpB74sjXJ786/tw+8wNgGIiN73eC/9akBGL1od43n4z3842g7oF+97vG43wTadfbfr4qUPHWoH9L4fX//b7SbYrLP0e679+uLPPnKoKdDL3h29/i73Z7dbYTOc9QJfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfSD/whfQDX0g/8IX0A19IP/CF9ANfnc3f/5/dTYfaAdB9naX/7ff7DrUDoPuspv+nv/zY0XYAdN+FcrnsdhsA3IGzXuAL6Qe+kH7gC+kHvpB+4AvpB76QfuAL6Qe+kH7gC+kHvpB+4AvpB76QfuAL6Qe+kH7gC+kHvpB+4AvpB76QfuAL6Qe+/g+uKd1XH1ExCAAAAABJRU5ErkJggg==" alt="very plain"></p><h2 id="修饰器函数" tabindex="-1"><a class="header-anchor" href="#修饰器函数" aria-hidden="true">#</a> 修饰器函数</h2><p>除了在声明对象时创建对象的属性与方法，或以函数表达式的形式将对象的属性与函数绑定，还可以使用修饰器函。修饰器函数接受对象输入（对象作为参数），并装饰对象（即为对象增加某些属性或功能，并返回该对象）。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 修饰器函数 carlike 为传递进来的对象增加位置 loc 属性，并返回该对象</span>
<span class="token keyword">let</span> <span class="token function-variable function">carlike</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> loc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>loc <span class="token operator">=</span> loc<span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用该修饰器函数 carlike，当传入对象为空 {} 时，还可以创建一个新对象 ben 增添新属性 loc</span>
<span class="token comment">// 一般创建新对象使用 类构造函数，而修饰器函数则是用来增强对象，为对象增添新属性</span>
<span class="token keyword">var</span> ben <span class="token operator">=</span> <span class="token function">carlike</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>💡 构造函数与修饰器函数类似，都是为对象设置新的属性和方法。但<strong>修饰器函数需要传递已有的对象</strong>；而构造函数不需要传递对象，使用操作符 <code>new</code> 调用时会隐式创建新的空对象。</p><h2 id="数组转换为对象" tabindex="-1"><a class="header-anchor" href="#数组转换为对象" aria-hidden="true">#</a> 数组转换为对象</h2><p>JavaScript 提供一个全局函数 <code>Object.fromEntries(arr)</code> 键一个由键值对组成的数组转换为对象。</p><p>对象缺少数组存在的许多方法，如 <code>arr.map()</code> ，如果我们想应用它们可以先使用方法 <code>Object.entries(obj)</code> 返回一个包含该对象所有 <code>[key, value]</code> 键值对的数组，处理后再使用 <code>Object.fromEntries(arr)</code> 将数组转换回对象</p><ol><li>使用 <code>Object.entries(obj)</code> 从 <code>obj</code> 获取由键/值对组成的数组。</li><li>对该数组使用数组方法，如 <code>arr.map(callback)</code></li><li>对结果数组使用 <code>Object.fromEntries(array)</code> 方法，将结果转回成对象。</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 将商品价格加倍
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // 转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象
  Object.entries(prices).map(([key, value]) =&gt; [key, value * 2])
);

alert(doublePrices.meat); // 8
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>💡 相应地，如果需要将<strong>可迭代或类数组对象</strong>转换为数组，可以<a href="/blog-web/frontend/JavaScript/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84" class="">使用方法 <code>Array.from(obj)</code></a></p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">更新时间: </span><span class="meta-item-info">2021/7/6 上午2:38:22</span></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><div style="width:0px;" class="catalog-container absolute top-0 right-0 h-full hidden lg:block"><div class="headings-container sticky top-36" data-v-c28348e0><ul class="max-w-max m-2 pl-7 xl:pl-16 2xl:pl-20 py-4 opacity-50 hover:opacity-100 transition-all duration-300" data-v-c28348e0><!--[--><!--]--></ul></div></div><div style="display:none;" tabindex="0" class="sidebar-container fixed inset-y-0 left-0 z-20 lg:hidden opacity-10 hover:opacity-95"><div class="headings-container px-2 space-y-2 transition-all duration-300 py-20" data-v-6eed9461><!--[--><!--]--></div></div></div><footer class="bg-gray-200 p-8 grid grid-cols-1 md:grid-cols-3 gap-4 items-center"><div class="flex justify-center md:justify-start items-center"><a class="p-2 hover:bg-gray-300 rounded-md" href="https://benbinbin.github.io/" target="_blank"><img src="/blog-web/images/avatar.png" alt="avatar" class="w-10 h-10 rounded-full"></a></div><div class="text-center space-y-0.5"><p class="text-sm text-gray-600"> ©2021 <span class="author">Benbinbin</span>. All Right Reserved. </p><p class="text-xs text-center text-gray-400"> 除特殊说明外，本站的文章遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" target="_blank" class="text-blue-400">CC-BY-SA-4.0</a> 协议 </p><p class="text-xs text-center text-gray-400"> 网站主题采用 <a href="https://github.com/Benbinbin/two-dishes-one-fish" target="_blank" class="text-blue-400">Two Dishes One Fish</a></p></div><div class="btn-container flex justify-center md:justify-end items-center space-x-0.5"><!--[--><a class="p-2 hover:bg-gray-300 rounded-md" href="mailto:benthomsonbin@gmail.com" target=""><img src="/blog-web/images/icons/email.svg" alt="email" class="w-auto h-6"></a><a class="p-2 hover:bg-gray-300 rounded-md" href="https://github.com/Benbinbin" target="_blank"><img src="/blog-web/images/icons/github.svg" alt="github" class="w-auto h-6"></a><a class="p-2 hover:bg-gray-300 rounded-md" href="https://juejin.cn/user/3175045314389278/posts" target="_blank"><img src="/blog-web/images/icons/juejin.svg" alt="juejin" class="w-auto h-6"></a><a class="p-2 hover:bg-gray-300 rounded-md" href="https://dribbble.com/BinBinDesign" target="_blank"><img src="/blog-web/images/icons/dribbble.svg" alt="dribbble" class="w-auto h-6"></a><a class="p-2 hover:bg-gray-300 rounded-md" href="https://twitter.com/Benbinbin_fun" target="_blank"><img src="/blog-web/images/icons/twitter.svg" alt="twitter" class="w-auto h-6"></a><a class="p-2 hover:bg-gray-300 rounded-md" href="https://weibo.com/binbindesign" target="_blank"><img src="/blog-web/images/icons/weibo.svg" alt="weibo" class="w-auto h-6"></a><!--]--></div></footer></div><!--]--></div>
    <script type="module" src="/blog-web/assets/app.43fe0c63.js" defer></script>
  </body>
</html>
