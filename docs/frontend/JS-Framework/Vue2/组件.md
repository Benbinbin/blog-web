---
show: true
collection: Re-Vue
collectionOrder: 2
summary: 这是看《[想入門，我陪你]Re Vue 重頭說起》视频教程和阅读 Vue 2 官方文档时做的笔记，这一篇主要是与组件相关的知识点，还包括一些需要注意的细节。
cover: re-vue.jpg
---



# Vue 2 组件

Vue 中的组件是页面中的一部分，通过层层拼装和复用，最终形成了一个完整的页面。

使用组件的一般场景：

* 代码复用
* 功能分类管理（每个组件实现一个功能）

组件必须先注册以便 Vue 应用能够识别，有两种组件的注册类型：

* 全局注册
* 局部注册

类似标签一样，通过组件名称来引用组件 `<component-name>`，:bulb: 由于 HTML 不支持大小写，所以在 name 使用驼峰式命名法时，**在引用组件写到 HTML 中时需要改为采用连字号**，因此**组件名称建议字母全小写，且对于多个单词组成的名字使用连字符号 `-` 分隔**

:bulb: 组件的 **data 选项必须是函数**，从中 `return` 对象

```js
Vue.component('myComponent', {
    data() {
        return {
            name: 'Ben'
        }
    }
})
```



## 全局组件

使用 Vue 原型 prototype 上的方法 `Vue.component()` 注册一个全局组件，第一个参数 `name` 是组件名称，第二个参数是一个对象包含组件相关的选项

```vue
Vue.component('name', {
  options,
  template: `...`
})
```

:warning: ==需要在 `new Vue({})` **之前**进行全局组件的注册==，之后它可以在任何地方（根组件或其他子组件的模板中）使用。

:bulb: 如果有大量基础组件，同时使用 webpack 工具，可以在[入口文件](https://vuejs.org/v2/guide/components-registration.html#Automatic-Global-Registration-of-Base-Components)进行配置，**使用 `require.context` 实现自动引入并进行全局注册这些组件**。



## 局部组件

通过一个普通的 JavaScript 对象来定义组件（提供组件的 options），然后在 Vue 实例的 `components` 选项中进行注册，之后它只能在该父级组件内使用

```js
const ComponentA = { /* ... */ }
const ComponentB = { /* ... */ }
const ComponentC = { /* ... */ }

new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

:clapper: 全局组件虽然可以在整个项目的所有其他组件（包括自己）中都可用，但是这可能造成构建项目时体积增大，用户下载 JavaScript 的无谓增加，因此不能滥用全局组件，视情况而定，如果组件自在特定父级中使用，应该将其注册为局部组件。

<iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=1177&end=1821&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

## 动态组件

基于标签 `<component>` 的 `is` 属性值（组件名），动态在不同组件之间进行切换



## 组件间数据传递

* 父组件将需要传递的数据绑定到子组件的属性上，子组件内部通过 props 接收。

* 子组件可以通过抛出事件 `$emit(eventName, value)` 同时传递数据，父组件监听事件并接收数据

### props

props 用于接收父组件传递的数据，需要在子组件的选项 `props` 中预先设置会有哪些 prop，可以以**字符串数组**形式列出，也可以以**对象**形式列出（可指定 prop 接收的数据类型、默认值、是否必须、验证条件等）。

需要注意以下几点：

* ==如果在父组件中传入的数据是非字符串的，需要**通过绑定 `v-bind:propName` 的方式来传递**（即使传递纯数字这一类的静态值）==；否则**直接传递数据都会转换为字符串**。

* :clapper: 如果 prop 是 Boolean 类型，但在使用组件中没有设置该 prop 时，则实例化后该组件的这个 prop 预设为 `false`；而使用组件时，设置了该 prop 但没有提供 true/false 值（no value 的情况），就会设置为 `true`。由于布尔类型不是字符串，正确传递方式是使用 `v-bind` 来传递非字符串的数据

  <iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=3884&end=4176&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

* prop 应该遵循==单向数据流==，即**不应该在子组件中修改 prop 值**（因为这些数据是在父层的），如果希望从子组件触发 prop 值的修改，可以通过子组件 `$emit('eventName', value)` 抛出事件同时传递需要更新的数据，然后在父级组件中监听事件，在回调函数中做修改。:clapper: 或者以 prop 值作为初始值或响应依赖：
  * 以 prop 传递来的数据作为一个初始值，在子组件接下来，拷贝到自己 data 的一个变量中
  * 基于 prop 定义一个计算属性，实现对原始的值的转换
  
  <iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=5159&end=5461&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

如果希望将一个对象的所有属性「拆分」为多个 prop 分别传入，可以使用不带参数的 `v-bind`（即 `v-bind="obj"`，而非 `v-bind:propName="obj"`），:clapper: 所以可以将大量的 prop 包装进一个对象，一次绑定到组件上

<iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=4633&end=4896&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

可以对 prop 进行限制，确保传递进来的值符合要求。有多个属性可以进行设置

```js
// ...
props: {
  propA: {
    type: String,
    required: true,
    default: 'abc',
    validator: func()   // 自定义验证函数，返回 true/false
  }
}
```

:warning:  prop 会在一个组件实例创建之前进行验证，所以该组件的 `data` 或 `computed` 数据在 `validator` 验证函数中无法进行访问

### emit



## 非 prop 属性

非 prop 的 attribute是指未在组件的 `props` 选项中显式声明的，但在引用组件时传递给子组件的 attribute，:clapper: 这些 attribute 会默认被添加到这个组件的**根元素**上（即在组件的模板中作为容器的第一层的 `<tag>` 上。

<iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=6820&end=6973&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

如果组件的根节点 `<tag>` 上已有预设了相应的 attribute，:clapper: 该属性就会被新传入的值**覆盖**；如果这个 attribute 是 `class` 或 `style`，会将它们与组件根元素上的 `class` 或 `style` **合并**。

<iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=7576&end=7810&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

:bulb: 如果希望 attribute 添加到组件的特定元素上，:clapper: 可以设定组件的选项 `inheritAttrs: false`，然后将特殊的变量 `$attrs`（这是一个包含所有非 prop 的 attribute 的对象）绑定 `v-bind="$attrs"` 到指定的节点上，**但 `class` 和 `style` 不能指定到组件的非根元素上**。也可指定某个 attribute 绑定 `:attributeName="$attrs.propertyName"`

<iframe style="width: 100%; aspect-ratio: 16/9;" src="https://www.youtube.com/embed/Q5xKDRdr0x8?start=6973&end=7506&modestbranding=1&rel=0" allowfullscreen loading="lazy"></iframe>

## 插槽

插槽 `<slot>` 在子组件中作为「占位符」预留位置，在引用组件时，在其中插入内容