# Vue 3 组件

![components](./images/components.png)

Vue 中的组件是页面中的一部分，通过层层拼装和复用，最终形成了一个完整的页面。

组件必须先注册以便 Vue 应用能够识别，有两种组件的注册类型：

* 全局注册
* 局部注册



## 全局组件

（在根组件中）使用==方法 `app.component('component-Name', {})` 来注册全局组件，全局注册的组件可以在应用中的**任何组件的模板中使用**==。

其中第一个参数时组件名，推荐遵循 [W3C 规范](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name)中的自定义组件名（避免与当前以及未来的 HTML 元素发生冲突）：字母**全小写**且**必须包含一个连字符**。

全局组件虽然可以方便地在各种组件中使用（包括其各自的内部），但是这可能造成构建项目时体积增大，用户下载 JavaScript 的无谓增加。

:bulb: 需要在 `app.mount('#app')` 应用挂载到 DOM 前进行全局组件的注册



## 局部组件

在一个（父）组件中组件的 ==`components` 选项中注册的组件==。

这些子组件**通过一个普通的 JavaScript 对象**来定义，其接收的参数和全局组件一样，但是==它们只能只能在该父组件中使用，称为局部组件==。

对于 `components` 对象中的每个 property 来说，其 **property 名就是自定义元素的名字**，其 property 值就是这个组件的选项对象。

```vue
const ComponentA = {
  /* ... */
}
const ComponentB = {
  /* ... */
}
const ComponentC = {
  /* ... */
}
```

```vue
// 然后在父组件的 `components` 选项中定义你想要使用的组件
const app = Vue.createApp({
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```



## 动态组件

内置的标签 `<component :is="componentName />"` 用以动态显式不同的组件，通过控制绑定在属性 `is` 上的参数值即可显示相应的同名组件。

:bulb: 有时候为了在切换时，保存动态组件的状态，例如组件中的输入框的值，可以用标签 `<keep-alive></keep-alive>` 包裹动态组件。



## 异步组件

现在的大型网页往往需要异步获取不同的数据，Vue 有一个 `defineAsyncComponent` 方法定义异步组件，以优化应用的加载和用户体验。

异步组件在加载页面时并不立即渲染，而是要等带一些业务逻辑完成后，才会执行组件内的逻辑和渲染到页面上。

```js
// 全局组件
const app = Vue.createApp({})

app.component('async-example', Vue.defineAsyncComponent(() => {
  return new Promise((resolve, reject) => {
    resolve({
      template: '<div>I am async!</div>'
    })
  })
}))

// 局部组件
import { createApp, defineAsyncComponent } from 'vue'

createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() => {
      return new Promise((resolve, reject) => {
        resolve({
          template: '<div>I am async!</div>'
        })
      })
    })
  }
})
```

异步组件的注册和一般的同步组件类似，如果是注册全局组件，也是使用 `app.component('component-name', {})`进行注册，不过第二个参数使用 `Vue.defineAsyncComponent()` 方法告诉 Vue 应用该组件是异步组件。

`defineAsyncComponent()` 方法的参数是一个匿名函数，而且函数是返回一个 Promise。在 Promise 内应该 `resovlve({})` 一个对象，其中包含了构建组件相关配置参数。只有当 Promise `resolve` 或 `reject` 才执行异步组件的处理。



## props

通过 Prop 向子组件传递数据。Prop 是在组件上注册的一些自定义 attribute，当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。

除了传递基础数据类型，==还可以传递**函数**作为 prop==。

```vue
// 注册一个全局组件
app.component('date-component',{
    props:['getDate'],
    methods:{
        clickHandler(){
            this.getDate()  // 获取当前时间
        }
    },
    template:`<div @click="clickHandler">打印当前时间</div>`
})
```

```vue
const app = Vue.createApp({
  data() {
    return {
      getDate: () => {
        const today = new Date();
        console.log(today.toLocaleDateString())
      }
    }
  },
  template: `
    <h2>Date</h2>
    <date-component :getDate="getDate" />
  `
})
```

## provide 和 inject

除了通过 props 从父组件向子组件传值，还可以用 provide 和 inject 实现从祖先组件向其子孙后代组件传值，不论组件层次有多深。

父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。

```vue
const app = Vue.createApp({})

// 父组件
app.component('todo-list', {
  provide: {
    user: 'John Doe'
  },
})

// 子组件
app.component('todo-list-statistics', {
  inject: ['user'],
  created() {
    console.log(`Injected property: ${this.user}`) // > 注入 property: John Doe
  }
})
```

:warning: 要访问父组件**实例 property**，我们需要将 `provide` 转换为**返回对象的函数**

```vue{8}
// 父组件
app.component('todo-list', {
  data() {
    return {
      todos: ['Feed a cat', 'Buy tickets']
    }
  },
  provide() {
    return {
      todoLength: this.todos.length
    }
  },
  template: `
    ...
  `
})
```

:bulb: 默认情况下，`provide/inject` 绑定并不具有响应式，可以通过合式 API `computed` 来实现数据的响应式。如果在 `setup` 中可以[使用`ref` property 或 `reactive` 对象包装变量](https://v3.vuejs.org/guide/composition-api-provide-inject.html#reactivity)，再传递给 `provide` 来实现响应式。

```vue
app.component('todo-list', {
  // ...
  provide() {
    return {
      todoLength: Vue.computed(() => this.todos.length)
    }
  }
})

app.component('todo-list-statistics', {
  inject: ['todoLength'],
  created() {
    console.log(`Injected property: ${this.todoLength.value}`) // > Injected property: 5
  }
})
```



## 插槽

插槽可以实现内容的分化。

在子组件的模板中定义插槽的位置

```vue
<!-- todo-button 组件模板 -->
<button class="btn-primary">
  <slot></slot>
</button>
```

然后在调用组件时，可以传递内容到插槽指定的位置

```vue
<todo-button>
  Add todo
</todo-button>
```

:hammer: 当组件渲染的时候，将会用给定的内容替换插槽，实现内容的分化。

```vue
<!-- 渲染 HTML -->
<button class="btn-primary">
  Add todo
</button>
```

:bulb: 可以在子组件模板的插槽标签内预置一些默认内容，它只会在没有提供内容的时候被渲染。

###  具名插槽

如果要将多个内容分发到子组件不同节点，可以在子组件模板中设置多个**具名操作**，即为子组件的标签 `<slot>` 添加属性 `name`。

```vue
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

然后在父组件中使用 `<template>` 元素，并以 ==`v-slot` 指令和相应的**参数**==指定内容分化到子组件的哪一个插槽。

:bulb: 其中参数 `default` 是默认插槽，如果分化内容不指定插槽名称时，都放到子组件的默认插槽中

```vue
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

:bulb: 设置具名插槽的指令 `v-slot:slotName` 有缩写 `#slotName`，例如 `v-slot:header` 是将内容分化到名为 `header` 的具名插槽中，可以缩写为 `#header`

```vue
<base-layout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <template #default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

:warning: 然而，和其它指令如 `v-bind:param` 缩写 `:param`、`v-on:eventName` 缩写 `@eventName` 一样，**该缩写只在其有参数的时候才可用**，这意味着以下语法是无效的：

```vue
<!-- This will trigger a warning -->

<todo-list #="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>

<!-- The right way -->
<todo-list #default="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>
```



### 作用域插槽

在父级组件中分化的内容，只能使用其作用域中的数据，而不能访问子组件的数据。

如果要**让分化的内容能够访问子组件中才有的数据**，需要在子组件模板设置插槽时，将数据绑定到插槽标签 `<slot>` 的相应属性上，这些 attribute 称为插槽 prop

```vue
// 子组件 todo-list 的模板
<ul>
  <li v-for="( item, index ) in items">
    <slot :item="item"></slot>
  </li>
</ul>
```

然后在父组件中，可以==用**指令 `v-slot` 的值**来接收子组件「抛出」的数据，该值是**包含所有插槽 prop 的一个对象**==

```vue
<todo-list>
  <template v-slot:default="slotProps">
    <span class="green">{{ slotProps.item }}</span>
  </template>
</todo-list>
```

![scoped slot](./images/scoped-slot.png)

:bulb: 如果组件只有一个插槽，可以把 `v-slot` 直接用在组件上，把组件的标签当作插槽的模板 `<template>` 来使用，即以上例子父组件分化内容可以简写为以下形式：

```vue
<todo-list v-slot:default="slotProps">
  <span class="green">{{ slotProps.item }}</span>
</todo-list>

// 甚至省略 default 参数
<todo-list v-slot="slotProps">
  <span class="green">{{ slotProps.item }}</span>
</todo-list>
```

:warning: 以上简写只能将内容分化到一个插槽，只要出现多个插槽，请始终为所有的插槽使用完整的基于 `<template>` 的语法。

:bulb: 如果父组件在分化内容时只使用了 插槽 prop 对象中某几个属性时，可以使用解构来简化代码

```vue
<todo-list v-slot="{ item }">
  <i class="fas fa-check"></i>
  <span class="green">{{ item }}</span>
</todo-list>

<!-- 解构也可以实现插槽 prop 属性的重命名，以下将 item 重命名为 todo -->
<todo-list v-slot="{ item: todo }">
  <i class="fas fa-check"></i>
  <span class="green">{{ todo }}</span>
</todo-list>
```

