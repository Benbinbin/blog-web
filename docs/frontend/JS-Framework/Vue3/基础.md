# Vue 3 基础

介绍 Vue 3 的基础使用方法，主要针对与 Vue 2 的不同点。 



## 起步

可以使用 CDN 引入最新版的 Vue 3 框架

```html
<script src="https://unpkg.com/vue@next"></script>
```

使用==方法 `.createApp()` 创建一个 Vue 实例应用，并使用方法 `.mount()` 将其挂载在指定的 DOM 上==

```html
<div>
    <div id="app"></div>
</div>
```

```html
<script>
	Vue.createApp({
        data() {
            return {
                conent: 'Hello World!'
            }
        }
        template: '<div>{{ conent }}</div>'
    }).mount('#app')
</script>
```

:bulb: 在方法 `.createApp()` 中可以使用 Vue 3 提供的各种参数/函数（包含在一个对象里），将数据渲染进页面，而且是**响应式**的：

* `data`
* `methods`
* `template`

:bulb: 当 Vue 实例挂载到页面后，返回**根组件**，是一个`Proxy`形式的对象。它就是 mvvm 设计模式中的 **`vm` 视图数据连接层**，能够在开发模式下，在浏览器的开发者工具的终端中使用它操作 Vue。

```js
const app = Vue.createApp({
    data() {
        return {
            content: 'Hello World!'
        }
    }
    template: '<div>{{ content }}</div>'
});

const vm = app.mount('#app');
```

```js
console.log(vm.$data.content)
```



## 响应式变量

在 `data()` 函数中声明响应式变量，然后将==它们作为返回值**包在一个对象中**==，这样在 Vue 的模板中就可以直接使用它们，在其他函数中则使用 `this.varName` 或 `this.$data.varName` 来访问。

```js
data() {
    return {
        counter: 1
    }
},
```



## 组件

### 全局组件

使用方法  `.compoennt()` 声明全局组件，其中第一个参数是组件名称，第二个参数是对象，包含各种组件的设置

```js
const app = Vue.createApp();
app.component('my-component', {
    template: `<h1>Hello World!</h1>`
});
const vm = app.mount('#app')
```

:bulb: 需要==在 Vue 挂载到页面**之前，完成全局组件的声明**==。



## 生命周期函数

![life cycle](./images/lifecycle.svg)

* `beforeCreate()` 在实例生成之前
* `created()` 在实例生成之后，可以访问响应性数据
* `beforeMount()` 在模板渲染完成之前
* `mounted()` 模板渲染完成之后，并完成挂载到 DOM 上
* `beforeUpdate()` 响应式数据发生变换，虚拟 Dom 执行重新渲染和更新前
* `updated()` 响应式数据发生变换，虚拟 Dom 执行重新渲染和更新后
* `beforeUnmount()` 销毁 Vue 实例时，销毁之前执行
* `unmounted()` 销毁 Vue 实例时，销毁之后执行

:bulb: ==销毁实例调用的函数是 `app.unmount()`==（其中 `app` 是 Vue 实例），相应的生命周期函数是 `beforeUnmount()` 和 `unmounted()`



## 属性绑定

使用 `v-bind` 指令绑定属性，可以用简写 `:`。

### 子组件 Attribute 继承

当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。

:bulb: 一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 [props](https://v3.cn.vuejs.org/guide/component-props) 或 [emits](https://v3.cn.vuejs.org/guide/component-custom-events.html#定义自定义事件) 定义的 attribute。常见的示例包括 `class`、`style` 和 `id` 属性。

:bulb: 如果你==**不**希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`==。禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。然后通过访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性，将该 property 手动绑定 `v-bind="$attrs"` 到所需的节点上，就可以将相应的 Attribute 应用到该节点。

```vue{5}
app.component('date-picker', {
  inheritAttrs: false,
  template: `
    <div class="date-picker">
      <input type="datetime-local" v-bind="$attrs" />
    </div>
  `
})
```

==另外在 Vue 3 中支持组件有多个根节点，但是这会对于**非 Prop 的 Attribute**绑定造成问题，所以**必须使用 `$attrs` 显式指定**这些 Attribute 绑定到哪个节点上。== 

```vue
// 这将发出警告
app.component('custom-layout', {
  template: `
    <header>...</header>
    <main>...</main>
    <footer>...</footer>
  `
})

// 没有警告，$attrs被传递到<main>元素
app.component('custom-layout', {
  template: `
    <header>...</header>
    <main v-bind="$attrs">...</main>
    <footer>...</footer>
  `
})
```

:bulb: 也可以绑定指定的某个 Attribute，例如只将 `class` 属性绑定到第一个根节点；在组件配置参数的业务逻辑中可以通过 `this.$attrs` 访问所有传递进来的非 props

```vue
app.component('custom-layout',{
    template:`
        <div :class="$attrs.class">Hellp</div>
        <div>World</div> 
    `
})
```

## v-if 与 v-for

在 Vue 3 中两者作用于同一个元素上时，`v-if` 会拥有比 `v-for` 更高的优先级，这与 Vue 2 中的工作方式正好相反，但这也造成==在同一个元素上 `v-if` 将没有权限访问 `v-for` 里的变量==

```vue
<!-- This will throw an error because property "todo" is not defined on instance. -->

<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```

[官方文档](https://v3.vuejs.org/guide/list.html#v-for-with-v-if)推荐使用 `<template>` 标签把 `v-for` 移动到「外层」来修正

```vue
<template v-for="todo in todos" :key="todo.name">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

:bulb: 但是更优化的方案是通过 `computed` 先对列表进行条件过滤，再迭代计算属性



## 事件处理

### 监听事件

使用 `v-on` 监听事件，或简写形式 `@`。

其回调函数默认传递 `event` 事件作为参数。

```vue
<div id="event-with-method">
  <!-- `greet` 是在下面定义的方法名 -->
  <button @click="greet">Greet</button>
</div>
```

```vue
// ...
methods: {
  greet(event) {
    // `event` 是原生 DOM event
    console.log(event)
  }
}

```

如果希望同时传递参数和事件，可以用特殊变量 `$event` 把事件传入回调函数中

```vue
<button @click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
```

```vue
// ...
methods: {
  warn(message, event) {
    // 现在可以访问到原生事件
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

支持设置多个事件处理函数，使用**逗号**分隔，而且回调函数即使没有传递参数也要加上 `()`

```vue
<!-- 这两个 one() 和 two() 将执行按钮点击事件 -->
<button @click="one(), two($event)">
  Submit
</button>
```

### 使用事件抛出一个值

在父子组件中间监听抛出的事件时，子组件在模板中使用 [`$emit()` 方法](https://v3.cn.vuejs.org/api/instance-methods.html#emit)抛出事件，第一个参数是事件名称，第二参数（可选）是需要传递的数据（如果基于子组件的事件被触发后，例如点击事件，再抛出自定义事件，可以使用特殊的变量 `$event` 作为参数，抛出子组件的事件）

```vue
<button @click="$emit('enlargeText', 0.1)">
  Enlarge text
</button>
```

```vue
<!-- 使用 $event 访问子组件的点击事件，然后作为自定义事件 enlargeText 的参数抛出，让父组件可以接收 -->
<button @click="$emit('enlargeText', $event)">
  Enlarge text
</button>
```

然后在父组件中监听这个事件，**其回调函数会将这个数据作为第一个参数**

```vue
<blog-post ... @enlarge-text="onEnlargeText"></blog-post>
```

```vue
methods: {
  onEnlargeText(enlargeAmount) {
    this.postFontSize += enlargeAmount
  }
}
```

:bulb: 如果父组件中不使用回调函数，而直接使用内联处理器的写法，可以使用 `$event` 访问到被抛出的这个值

```vue
<blog-post ... @enlarge-text="postFontSize += $event"></blog-post>
```

### `emits`选项

Vue 3 目前提供一个 `emits` 选项，和现有的 `props` 选项类似。这个选项可以**用来定义组件可以向其父组件触发的事件**。

该选项也可以接收一个对象，该对象==允许开发者定义**传入事件参数的验证器**==，和 `props` 定义里的验证器类似。

:bulb: 强烈建议使用 `emits` 记录每个组件所触发的所有事件。

```vue
<template>
  <div>
    <p>{{ text }}</p>
    <button v-on:click="$emit('accepted')">OK</button>
  </div>
</template>
<script>
  export default {
    props: ['text'],
    emits: ['accepted']
  }
</script>
```

